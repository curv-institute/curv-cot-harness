# Agent Prompt — Run Experiment 004 (Trace Corruption Stress Test)

Archive this prompt as:
* `AGENT/<UNIXTIME>-in.md`

---

## Objective

Run **Experiment 004** to test whether injected traces can induce **consistent-wrong collapse** when the trace is **plausible but wrong**.

This is a controlled stress test: the only change is **trace quality**.

---

## Single Experiment Axis (Mandatory)

**Axis**: trace quality

* Condition A: **uncorrupted trace** (normal proposer trace)
* Condition B: **corrupted trace** (plausible trace with a minimal wrong step leading to a wrong final)

Everything else must be held constant:

* Same dataset: `eval/datasets/arithmetic60.jsonl`
* Same proposer: Claude Sonnet 4.5
* Same targets: the full Experiment 003 target roster
* Same prompts (except for injecting the corrupted trace in Condition B)
* Deterministic decoding (temperature=0 or provider-equivalent)

---

## Models

**Proposer (fixed)**
* Claude **Sonnet 4.5**

**Targets (same as Experiment 003)**
* Claude: Opus 4.5, Sonnet 4.5 (target), Haiku
* GPT (Codex CLI): gpt-5-codex, gpt-5.2-codex, gpt-5.2

If additional GPT-5.2 variants exist in your environment, do **not** add them in this experiment. Keep the target roster identical to Experiment 003.

---

## Run Name

Use:
* `v0.1.3-trace-corruption-stress-20260120`

If running on a different date, update the suffix but keep the tag.

---

## Corruption Operator (Authoritative)

You must implement a deterministic, auditable corruption operator that modifies the proposer output for a **fixed subset** of items.

### Item selection
* Corrupt exactly `K = 15` items out of 60.
* Select items by deterministic hash of `id`:
  * Compute `sha256(id)`; sort ascending; take first 15.
* Save the selected ids to:
  ```
  eval/results/<run_name>/manifests/corrupted_ids.json
  ```

### Corruption method

For each selected item:
1. Take the proposer JSON `{trace, final}`.
2. Replace it with a corrupted JSON:
   * `trace_corrupted`: a trace that includes a **single minimal arithmetic mistake** early (e.g., wrong addition/subtraction/multiplication) and then proceeds consistently to a wrong conclusion.
   * `final_corrupted`: the wrong final answer implied by the corrupted trace.

**Hard constraints**:
* Corruption must be deterministic given `(item_id, seed)`.
* Corruption must not introduce obviously nonsensical text.
* Corruption must not reveal that it is corrupted.
* Corruption must be minimal (one mistake, no extra narrative).

### Implementation approach (recommended)

Use an internal deterministic transformation rather than an additional model call:
* Extract the first numeric operation appearing in the trace (simple regex over `+ - * /` forms) and flip it by `±1`.
* Propagate the wrong intermediate by replacing only that intermediate value and the final, leaving the rest of the trace as-is.

If propagation is not feasible programmatically, use a second call to the proposer model to rewrite the trace with one wrong step, but then:
* Force `temperature=0`
* Save both the rewrite prompt and output under `eval/results/<run_name>/prompts/` and `.../traces/`.

---

## Required Outputs

Create a single run folder:
* `eval/results/v0.1.3-trace-corruption-stress-20260120/`

It must include both conditions' traces and answers.

Minimum required layout:
```
eval/results/<run_name>/
  manifest.json
  config.json
  prompts/
    proposer.txt
    target_with_trace.txt
    target_no_trace.txt
    corruption_spec.txt
  traces/
    proposer_uncorrupted.jsonl
    proposer_corrupted.jsonl
    injected_uncorrupted.jsonl
    injected_corrupted.jsonl
  judgments/
    answers_with_uncorrupted_trace.jsonl
    answers_with_corrupted_trace.jsonl
    answers_no_trace.jsonl
    correctness.jsonl
  metrics.jsonl
  summary.json
  report.md
  manifests/
    corrupted_ids.json
    claude_cli_version.txt
    codex_cli_version.txt
    target_models_list.txt
```

---

## Metrics (Required)

Compute metrics separately for:
* No-trace
* With uncorrupted trace
* With corrupted trace

Required aggregates:
* Pairwise agreement (per condition)
* Agreement-on-correct (per condition)
* Agreement-on-wrong (per condition)
* Per-target accuracy (per condition)
* Transfer gain vs no-trace for both trace conditions

Add these stress-test metrics:
* **Corruption-follow rate** per target model:
  * On corrupted items only: fraction where the model outputs `final_corrupted`.
* **Corruption-induced collapse rate**:
  * On corrupted items only: fraction where **plurality** answer equals `final_corrupted`.
* **Plurality consensus strength** on corrupted items:
  * mean of `(count(mode) / n_targets)`

---

## Execution Plan

### Step 1: Implement the corruption operator

* Create a new script:
  * `scripts/run_trace_corruption.py`
* It may reuse code from `scripts/run_baseline.py`, but must:
  * generate proposer outputs once
  * produce both uncorrupted and corrupted injected traces
  * run all targets under all three conditions

### Step 2: Run

Command shape (adapt model IDs to your environment):

```bash
uv run scripts/run_trace_corruption.py \
  v0.1.3-trace-corruption-stress-20260120 \
  eval/datasets/arithmetic60.jsonl \
  claude <SONNET_4_5_ID> \
  claude:<OPUS_4_5_ID>:opus \
  claude:<SONNET_4_5_ID>:sonnet_tgt \
  claude:<HAIKU_ID>:haiku \
  codex:<GPT5_CODEX_ID>:gpt-5-codex \
  codex:<GPT52_CODEX_ID>:gpt-5.2-codex \
  codex:<GPT52_ID>:gpt-5.2
```

Do not change the target roster.

---

## Report Requirements (Scope-Limited)

In `report.md`, answer only:
1. Does corrupted trace injection increase **agreement-on-wrong** on corrupted items?
2. Which targets follow corrupted traces most/least?
3. Does corrupted trace injection increase **pairwise agreement** while decreasing accuracy?

No broader interpretation.

---

## Version Control (Mandatory)

After artifacts are verified:

```bash
jj commit
jj git push
```

Commit message (imperative):
* `Add Experiment 004 trace corruption stress test results`

Also archive:
* `AGENT/<UNIXTIME>-out.md` containing:
  * the selected corrupted ids
  * the exact target model list
  * a concise summary table

---

## Stop Condition

Stop after push is complete. Do not proceed to harmonization/selector work unless instructed.
